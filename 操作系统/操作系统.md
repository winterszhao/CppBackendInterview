## 操作系统

为了屏蔽底层不同硬件的差异，使应用层的用户在编写程序时调用统一的接口

CPU位数 ALU算数逻辑单元的宽度，数据总线的条数（32位是这样，别的位数cpu不是这样）

怎么工作的？取指执行（取PC指针指向的内存保存的指令到寄存器中，执行指令）

**开机：**

1. 刚开机是出于实模式（实模式寻址与保护模式不同，CS:IP(CS左移4位+IP，20位只能访问1M)）

2. 1

3. 1

4. 1

5. 引导扇区

   ```shell
   # boot扇区boostsect.s：
   # 移动读进来的引导扇区代码（boot扇区）从BOOTSEG=0x07c0到INITSEG=0x9000
   # int 0x13读磁盘，读4个扇区（setup扇区）
   # int 0x10打操作系统logo
   # int 0x13读磁盘，读操纵系统其他模块。
   # 跳转到setup继续执行
   
   # setup扇区setup.s
   # int 0x15 读内存大小到内存0x90002等各种硬件参数到0x90000处
   # 把操作系统移动到0地址处
   # 寻址方式切换保护模式（cr0寄存器PE=1, 地址翻译方式改变：cs选择子（选择gdt中的表项）+ip）
   # 初始化gdt表，idt表
   # 跳到0地址处执行head.s
   
   # 操作系统head.s（32位汇编）
   # 压栈跳到main执行，main返回到L6, L6是jmpL6死循环
   # 初始化页表
   
   # main
   # main中初始化tty，内存mem_map物理内存哪页有使用
   
   ```

**系统调用：**应用程序不应该能直接操作操作系统内存，不安全，

- **内核态和用户态隔离：**访问**DS数据段的最低两位DPL**表示用户特权级，**CS代码段最低两位CPL**表示用户特权级，当当前特权级>=目标特权级时才能访问，用户态特权级3比内核态特权级0低。
- **中断进内核是进入内核的唯一方法：**设置系统调用号到eax，然后调用中断`int 0x80`（初始化时DPL设成了3，故意让用户能访问），中断处理system_call（CPL置为0进入内核态），查idt表sys_call_table找到对应系统函数并执行，返回时CPL又设置成3恢复用户态。 MMU来改（进内核慢在这里）。

# 进程与线程

**并发：**多道程序交替执行（为了提高cou利用率，io速度很慢）

**进程线程切换：**

- **用户级线程：**代价小不用TCB

  1. 每个线程有**自己的栈**，TCB存放栈esp指针，通过yield右大括号弹栈，不然线程切换压栈出栈会乱，
  2. **yield()：**调用yield函数压栈（压入原来栈下一条执行地址），yield压入现场，找到下一个TCB并切换栈帧esp，yield右大括号弹栈（下一个栈下一条执行地址）。
  3. 缺点：无法利用多核，并发度差一旦有用户级线程在内核停住了其他也会阻塞，

- **内核级线程：**yield由内核来执行。操作系统可以分配多核，充分利用CPU。

  - **五段论：**每个线程需要有两个栈：**用户栈和内核栈**，

    1. **中断出入口：**

       **入口：**int0x80执行时，压内核栈，栈中保存用户栈的ss和sp（栈顶和栈底），EFLAGS，cs和ip（执行位置）。中断处理中systemcall中压入用户态寄存器状态到tss。

       **出口：**弹出ss:sp,EFALGS,cs:ip，IRET中断返回到用户栈。

    2. **是否用切换：**PCB的state是不是0，时间片是不是用完了，非零就调度。

    3. **schedule()找下一个TCB：**CPU调度

    4. **switch_to内核栈切换：**TR置成新的tss描述符，找到新的tss，赋值所有的寄存器。IRET中断返回在用户态继续执行。

## 进程

**PCB：**进程与程序不同需要来回切换，这样每个程序就需要有个数据结构（task_struct）来存放记录切出去程序时的上下文（返回地址，ax ，bx寄存器状态等）返回时继续执行。同时为了进程间资源隔离，有自己的虚拟地址空间，打开的文件描述符表等

1. **进程描述信息：**进程id，用户id和组id
2. **进程控制和管理信息：**进程状态和进程优先级
3. **资源分配清单：**
   - 虚拟地址空间信息，mm的pgd指针指向三级页表
   - 打开的文件描述符表，数组指向数据结构保存dentry
4. **CPU相关信息：**进程切换时需要保存和恢复的CPU寄存器
5. 未决信号集和信号屏蔽字

**多进程状态：**PCB进程有5种状态，PCB通过链表组织，不同状态保存在不同链表中（链表方便添加删除），就绪态在就绪队列，阻塞态在磁盘等待队列。

1. 创建态（New）：进程正在被创建时的状态。
2. 就绪态（Ready）：进程创建完成并初始化后，进入就绪态，这时可运行，可分配时间片，但是其他进程正在运
3. 运行态（Running）：cpu调度选中，运行进程，这时进程正在占用CPU
4. 阻塞态（Blocked）：进程阻塞等待某个事件，进程等待某一事件发生（如输入输出完成）而暂停运行。
5. 挂起态：进程内存页被换出到磁盘。
6. 结束态（End）：进程退出，进程正在从系统消失的状态。

**几种进程：**

1. **孤儿进程：**父进程结束后，子进程不会结束，子进程的父进程变成init进程。

2. **僵尸进程：**进程终止，父进程没有回收（wait）子进程，子进程的残留资源PCB存放在内核中，成为僵尸进程。

   wait，waitpid阻塞：父进程需要知道子进程的退出状态。

3. **守护进程：**后台服务进程，独立于终端周期性，一般不与用户直接交互，周期性执行某种命令或等待处理某些发生的事件。

   **创建流程：**

   1. 父进程创建子进程
   2. 子进程setsid()创建会话（进程组组长不能创建会话），成为组长进程，进程id，进程组id，会话id相同，丢弃原有的控制终端。
   3. 改变当前工作目录位置chdir()（防止工作在可卸载目录，目录被删了崩了）
   4. 重设文件权限掩码umask()（防止继承的文件屏蔽字拒绝某些权限）
   5. 关闭close不用的文件描述符，或者重定向dup不用的文件描述符到空洞/dev/null（防止浪费系统资源，继承的文件描述符0,1,2标准输入输出错误等）
   6. 执行守护进程逻辑

**fork()：**子进程返回0，父进程返回pid

- **父子区别：**子进程返回0，父进程返回pid，父子进程继续执行fork下面的指令
  
  1. 父子进程相同：刚fork后的用户空间，父子写内存时不同，读时共享写时赋值
  2. 父子不同PCB中的一些内容：pid，ppid, 进程创建时间，闹钟，未决信号集
  3. **父子共享：**文件描述符，mmap映射区
  
- **创建进程：**做成能切换的样子。
  1. 创建栈mem_map中找空闲页；
  2. **初始化tss**（创建内核栈，创建用户栈，初始化两个栈（内核栈关联用户栈（初始化ss,sp,EFLAGS,cs:ip**置成elf header的入口地址**））；
  3. 关联内核栈和TCB（esp保存内核栈指针）；
  4. TCB状态改为就绪；TCB入就绪队列。

- **进程：**操作系统启动1号进程shell

  - **多进程如何切换：**进程调度getNext得到下一个进程的PCB，PCB中的内容覆盖CPU中内容并切换到下一个进程执行switch_to

  - **内存管理：**多个进程的地址空间分离，映射表。通过MMU映射。

    - **CPU调度：**

      指标：

      - 周转时间：从任务进入到任务结束
      - 响应时间：从操作到响应
      - 吞吐量：完成的任务量

      不同任务关注点不同：前台任务关注响应时间（I/O约束型任务），后台任务关注周转时间（CPU约束型任务）

      **调度算法：**

      1. **FIFO先来先服务：**先进先出，平均周转时间太长（短作业后进入也要等前面的长作业完成）
      2. **短作业优先SJF：**短作业优先调度，平均周转时间最短（长作业可能一直拿不到CPU，响应时间无法保证）
      3. **Round Robin：**按时间片来轮转调度（响应时间可以保证）
      7. **Linux0.11调度：**
         - 优先级：一个数组，遍历找最大就绪态进程的counter调度，所有就绪态执行完成后（couter/2 + 初值，这样io阻塞没执行的进程回来之后优先级更高，前台进程的特征）
         - 时间片：时钟中断之后，--counter，减到0调度其他进程执行。
         - 优点：
           1. counter时间片保证了响应时间（c(t) = c(t-1)/2 +P极限收敛2P），
           2. 经IO优先级变高照顾了前台进程，
           3. 后台按counter轮转近似了SJF，
           4. 整个进程只用维护一个counter变量，简单

## 进程间通信IPC

内核空间的一块缓冲区

1. **管道pipe：**内核中的环形队列（会扩容），管道是单向的，数据不能反复读取，半双工的方式通信：

   - **匿名管道pipe，有名管道fifo：**匿名只能在有血缘关系的才能使用（继承打开的文件描述符），有名可以非血缘（起了一个文件名，文件的用法）。

   - `pipe(int fd[2]);`  fd[0]读端，fd[1]写端。一般单向传递，父子进程关闭close读写一端（父写子读）

   - **管道读写行为：**
     1. 读管道：
        1. 管道中有数据，返回实际读到的字节数
        2. 管道中无数据：
           1. 管道写端全部关闭：read返回0，类似于读到文件尾。
           2. 写端没有全部关闭：阻塞，等待写端写入。
     2. 写管道：
        1. 管道读端全部关闭，进程异常终止（信号SIGPIPE导致）
        2. 管道读端没有全部关闭：
           1. 管道已满：阻塞，等待管道不满。
           2. 管道未满：返回写入的字节个数。
     
   - **默认缓冲区大小：**`ulimit -a`，4096

   - **优点：**简单

     **缺点：**

     1. 单向通信，双向通信需要建立两个管道
     2. 数据不能重复读取

2. **共享内存映射mmap：**零拷贝，节省了从内核拷贝数据到用户空间的开销。磁盘中的文件映射到用户空间文件映射区内存中，**可以直接在内存中用指针操作**。flag参数修改是否反应到磁盘上（是，否（不能进程间通信）），offset必须是4k的整数倍（MMU映射的最小单位，一页？）

   - **普通文件：**一个文件的文件区被分成页大小，映射到虚拟内存中，第一次访问时换入到物理内存。open一个文件，传入fd

     **匿名文件：**直接初始化0一个物理页。指定`flag|=MAP_ANONYMOUS`，描述符-1

   - **共享对象：**`flag|= MAP_SHARED`对映射的文件映射区可以执行写，且写操作对其他进程可见，变化反应到磁盘上。

     **私有对象：**`flag|=MAP_PRIVATE`，对映射的文件映射区不可以执行写，且写操作对其他进程不可见，变化不会反应到磁盘上。实现：**写时复制**，映射的共享区域被标记位只读，写操作触发保护故障，处理函数会复制页并更新页表指向这个页。

   - **优点：**无血缘关系通信，数据可以重读读取
   - **信号量：**可用于进程访问同一块内存（共享文件映射区）的同步。

3. **信号：**内核产生内核处理，产生->未决->抵达，四要素：编号，名称，事件，默认处理动作

   - **产生信号的方式：**

     1. 按键产生：ctrl+c，d

     2. **系统调用产生：**`kill(pid，信号)`函数，pid>0指定进程，=0同一进程组所有进程，<0|pid|对应进程组，=-1进程有权限发送的系统中所有进程（）。

     3. **软件条件产生：**alarm定时器，每个进程只有一个唯一的定时器，定时到了发信号

        setitimer(计数的形式)

     4. 硬件异常产生：段错误，

     5. 命令产生：kill命令

   - **抵达：**递送并且到达进程

   - **未决：**未决信号集中信号位为1的状态，产生和抵达之间的状态。

     - **未决信号集：**信号产生之后将对应信号位置1，判断如果信号屏蔽字对应信号位为1，则无法抵达（**多次只执行一次**）。否则，抵达处理函数并置为0。

       通过`sigemptyset,sigaddset,sigdelset`把自己的set信号位置1，位或内核的未决信号集

     - **信号屏蔽字：**用于屏蔽信号，屏蔽信号后，产生的信号无法抵达，解除屏蔽后，未决信号抵达并调用信号处理。

       通过procmask把自己的set，位或信号屏蔽字。

     - **信号处理方式：**

       1. 执行默认操作，查手册

       2. 忽略（丢弃）

       3. 捕捉（调用注册的用户处理函数）

          ANSI定义：signal处理函数传入信号编号

          POSIX定义：sigaction，sa_mask只在信号捕捉函数执行期间生效（防止重复信号导致信号捕捉函数又跳转到开头重新执行，或者执行当前信号时屏蔽其他信号），sa_flag=0默认本信号屏蔽。

          特性：

          1. 信号捕捉函数执行期间，信号屏蔽字由PCB的mask**转为处理函数的sa_mask**，捕捉函数执行结束，回复回mask。

          2. 信号捕捉函数执行期间，本信号自动屏蔽sa_flags=0。

             sa_flags=SA_RESTART慢系统调用read等，处理中断返回时，继续处理慢系统调用

          3. 信号捕捉函数执行期间，**信号多次发送，解除屏蔽后只处理一次**（不支持排队）

   - **内核实现：**

     1. 中断进入内核（信号并不是立即执行）
     2. 内核处理完中断处理之后，返回用户态之前，dosignal()处理当前进程中的信号。
     3. 如果有信号捕捉处理函数，回到用户态执行处理函数，sigreturn()再次进内核。
     4. 返回用户态从中断的地方继续执行。

   - SIGCHLD只要进程状态变化就向父进程发信号，默认忽略，可以捕捉回收子进程。

4. **本地套接字：**最稳定

5. **消息队列：**

## 线程

进程是分配资源的最小单位，线程是cpu执行的最小单位。

**线程 ：**linux中轻量级进程，有独立的PCB，底层和进程一样都是clone，但是没有独立的内存地址空间（三级页表是相同的）。操作系统中有线程号LWP，操作系统把线程按进程来调度。

**优点：**方便数据共享，减少上下文切换开销，只切指令不切资源（内存映射表）。保留了并发的优点，避免了进程切换的代价。

**用户线程：**线程由用户管理和调度

- 优点：
  - 无需用户态和内核态切换开销更小
  - TCB由用户维护可用于不支持线程的操作系统。
- 缺点：
  - 一个用户线程阻塞，进程包含的所有用户线程都不能执行。
  - 一个线程除非主动yield让出CPU，否则一直执行。
  - 操作系统分配时间片给内核线程，每个用户线程的时间片会少
  - 无法利用多核，CPU不能充分利用。

**内核线程：**LWP轻量级线程，线程由操作系统管理和调度

- 优点：
  - 阻塞不会影响其他线程
  - 充分利用多核CPU
  - 每个线程能获得更多的时间片
- 缺点：
  - 需要由内核保存线程上下文信息TCB
  - 线程的创建，终止和切换都是通过系统调用的方式，需要进内核，开销较大。

**线程共享资源：**

1. 文件描述符表
2. 每种信号的处理方式，mask不共享（可以指定线程处理信号）
3. 当前工作目录
4. 用户id组id
5. 内存地址空间（除了栈）

**线程非共享：**

1. 线程id
2. 处理器现场和栈指针（复制一份用户栈，初始化内核栈）
3. errno变量（线程得用线程退出的返回值）
4. 信号屏蔽字mask
5. 调度优先级

**注意：**

- **避免僵尸线程：**pthread_join, 或pthread_detach设置分离或pthread_create时设置属性分离
- **避免混用线程进程：**进程中有线程调用fork，子进程中只有调用fork的线程存在其他全部pthread_exit()了。
- **避免混用线程和信号：**线程共享同一套处理函数和未决信号集，但是有自己的mask屏蔽字，通过屏蔽字指定哪些线程不处理信号。

**优缺点：**

- **优点：**轻量切换开销小，数据通信共享数据方便。
- **缺点：**库函数不稳定，调试困难（gdb不支持），对信号支持不好

**线程：**

```c++
int pthread_create(线程id，属性(分离等), 函数指针，函数传参);	
    		// tid线程id是进程中标识线程用，线程号LWP是操作系统调度用（和pid作用相同），
			// 函数传参（void*得用堆上或全局，不能用栈上（因为栈上空间可能随父线程的销毁而销毁））
void pthread_exit(void* retval);	
			// 线程退出，线程函数return也行，exit()退出进程
void pthread_join(pthread_t thread, void **retval);	
			// 回收线程资源，看线程的退出值retval
void pthread_cancel(pthread_t thread);				
			// 杀死线程，必须到取消点(中断进内核)，线程退出值-1。
			// 但是线程中while(1)的话一直进不了内核就杀不死。可以在线程中手动加取消点,pthread_testcancel();
int pthread_detach(pthread_t thread);	
			// 设置线程分离，自己回收pcb资源

// 线程属性，线程创建时就可以指定好（分离属性，线程栈大小等）
int pthread_attr_init(pthread_attr_t * attr);	// 初始化线程属性
int pthread_attr_destroy(pthread_attr_t* attr);	// 销毁线程属性所占资源
int pthread_attr_setdetachstate(pthread_attr_t* attr, int*detachstate);	// 设置线程分离属性

```

|          | 线程           | 进程         |
| -------- | -------------- | ------------ |
| 创建     | pthread_create | fork         |
| 获取id   | pthread_self   | getpid       |
| 退出     | pthread_exit   | exit         |
| 回收资源 | pthread_join   | wait/waitpid |
| 杀死     | pthread_cancel | kill         |
| 分离     | pthread_detach |              |

## 线程同步

访问共享资源（数据，fd等）

**死锁：**互相等锁释放

线程同步方式：

可重入锁不可重入锁：

1. **锁：**锁的粒度越小越好，访问共享内存之前加锁，之后立即解锁

   - **互斥锁：**

     ```c++
     pthread_mutex_init   pthread_mutex_destroy	// 初始化销毁
     pthread_mutex_lock	 pthread_mutex_unlock	// 加解锁（阻塞）
     pthread_mutext_trylock						// 试图加锁（非阻塞），失败EBUSY
     ```

   - **读写锁：**读共享，写独占（可以重复加读锁，加写锁读写都阻塞）

     - 加写锁：加读写锁都阻塞；加读锁（读锁成功，写锁失败，读写同时阻塞**写锁优先**）

       ```c++
       pthread_rwlock_init  pthread_rwlock_destroy	// 初始化销毁
       pthread_mutex_wrlock pthread_mutex_rdlock	// 加解锁（阻塞）
       pthread_mutex_unlock
       pthread_mutext_trywrlock pthread_mutex_tryrdlock a// 试图加锁（非阻塞），失败EBUSY
       
       ```

   - 

   - restrict关键字指针指向的内存操作只能由本指针完成

# 内存管理

## 虚拟地址

- **why：**操作系统的进程是共享cpu和主存资源的，

  1. 如果需要太多内存进程无法生存
  2. 多个进程之间直接使用物理地址，会导致物理内存争夺和践踏

- **what：**操作系统提供的一种机制，cpu通过MMU将不同进程的虚拟地址和物理地址映射起来

- **how：**

  1. **段式管理：**

     - **解决的问题：**解决多进程直接使用物理内存的争夺践踏问题。

     - **解决：**（符合用户的观点）程序由不同逻辑分段组成：C语言**代码段，数据段，BSS段，堆段，栈段，文件映射区**。不同分段有不同属性，所以用分段的形式把这些段分离出来

       虚拟地址分为两部分：**段选择子**和**段内偏移量**

       1. **段选择子**保存在段寄存器中：段号和特权标志位
       - **段号：**段表的索引，找到段表中的段内描述符：段基地址，段界限，特权等级
       
       2. **段内偏移量**：应位于0和段界限之间，如果合法，物理地址 = 段基地址+段内偏移量
       
     - **引入的问题**

       1. **内存碎片：**
       
          - **外部内存碎⽚：**也就是产⽣了多个不连续的⼩物理内存，导致新的程序⽆法被装载；
       
            **解决：**内存交换，内存交换到磁盘的swap空间上，再紧挨着上个被占用的空间交换回内存中。
       
          - **内部内存碎⽚：**程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并**不是很常使⽤**，这也会导致内存的浪费。
       
       2. **内存交换效率低：**每次交换都要把整个程序一大段连续内存写到硬盘上，这样效率很低。
  
     ![](src\段式管理.png)
  
  2. **页式管理：**
  
     - **解决的问题：**段式管理有内存碎片和交换效率低的问题。
     - **解决：**分⻚是**把整个虚拟和物理内存空间切成⼀段段固定尺⼨的⼤⼩**。这样⼀个连续并且尺⼨固定 的内存空间，我们叫⻚（Page）。在 Linux 下，每⼀⻚的⼤⼩为 4KB 。
  
       - 这样释放内存是以页为单位，不会产生无法给进程使用的小内存。换入换出只是少数的页，内存交换的效率更高。
  
       - 因为换入换出效率更高：程序运行时，无需把页加载到物理内存中，需要用到虚拟内存页的指令和数据时，再加载到物理内存里面去。
  
       - 虚拟内存与物理地址之间通过**页表**来映射：虚拟地址分为两个部分页号和页内偏移
  
         - 页号：页表的索引，页表包含物理页号（可找到每页所在物理内存的基地址）
         - 物理地址 = 物理页号+页内偏移
     - **引入的问题：**页表占用内存，每个进程都需要单独的页表映射整个物理地址。
  
  3. **多级页表和快表：**
  
     - **多级页表：**
  
       - **解决的问题：**每个进程都需要页表，只用单个页表划分虚拟内存，多个页表占用空间大。
       - **解决：**所以可以创建多级的页表，一级页表表示更大的范围，如果二级页表项没有被用到，就不创建这个页表项对应的二级页表，可以需要时才创建二级页表。
  
       ![多级页表](src\多级页表.png)
  
     - **引入的问题：**多级页表解决了空间消耗的问题，但是引入了额外的时间开销（地址多次转换）
  
  4. **快表TLB:**
  
     - **解决的问题：**多级页表的时间消耗。
     - **解决：**因为程序的执行是有空间有局部性的，整个程序的执行只局限于程序的某一部分。利用这一特性，把最常访问的页缓存起来放在CPU中就是快表。先查快表，如果没找到，再查常规页表。

4. **段页式内存管理：**

   分段和分页并不对立，可以组合起来在同一个系统中使用，组合起来称为段页式内存管理。

   - 先将程序划分为多个有逻辑意义的段，接着再把每个段划分为多个页。这样每个程序一张段表，段表中的地址是页表的起始地址。访问物理地址须景观三次内存访问：

     - 访问段表，获取页表起始地址

     - 访问页表，得到物理页号

     - 物理页号+页内偏移，得到物理地址

    ![段页式](src\段页式.png)

  5. **Linux内存管理：**

     Intel处理器：在段式管理的映射的地址上在加上再加上一层地址映射。段式管理先将**逻辑地址**映射成**线性地址**，然后再由页式管理将线性地址映射成物理地址。

     **Linux 内存：**主要采⽤的是⻚式内存管理，但同时也不可避免地涉及了段机制：**Linux**每个段都是从0开始的整个4GB虚拟空间（32位环境）**，也就是所有的段的起始地址都是一样的。这样Linux系统中的代码，所面对的地址空间都是线性地址空间（虚拟地址），这种错发相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。

     虚拟地址空间内部被分为**内核空间**和**用户空间**两部分：

     - 32位系统：寻址空间2^32->4G，内核空间高1G，用户低3G。64位系统：2^64内核高128T，用户空间低128T，中间未定义。

     - 进程在用户态时，只能访问用户空间。只有进入内核态后才能访问内核空间的内存。
     - 虽然每个进程都各自又独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样进程切换到内核态后，就可以很方便地访问内核空间内存。

     ![](src\内核和用户.png)

     用户空间：从低到高分别是7中不同的内存段

     1. 程序文件段.text：包括二进制可执行指令
     2. 已初始化数据段.data：包括静态常量
     3. 未初始化数据段.bss：包括未初始化的静态变量
     4. 堆段：包括动态分配的内存，**从低地址开始向上增长**
     5. 文件映射段：包括动态库，共享内存等，从低地址开始向上增长
     6. 栈段：包括局部变量和函数调用上下文等。栈大小固定一般是8M，操作系统也提供了参数来自定义大小。

# 进程与线程   ​ 

**并行与并发：**并行程序同时运行，并发程序交替运行

 **进程的状态：**

1. **创建状态（new）：**进程正在被创建时的状态。
2. **就绪状态（Ready）：**进程创建完成并初始化后进入就绪队列，转为就绪态。可运行，但是其他进程占用cpu时间片。
3. **运行状态（Running）：**进程调度器选中后执行进程，正在运行，进程占用CPU时间片。
4. **阻塞状态（Block）：**进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂停运行，这时，即使给它CPU控制权，它也无法运行。
5. **挂起状态（Suspended）：**内存换出到磁盘，没有实际占用物理内存空间。阻塞，资源限制，用户调用系统函数pause。
   - 阻塞挂起态：进程在外存，等待某个事件出现。
   - 就绪挂起态：进程在外存，只要换入到内存立即执行
6. **结束状态（Exit）：**进程正在从操作系统消失的状态。

**进程的控制结构：**操作系统中是用进程控制块（PCB，task_struct）数据结构来描述进程的。PCB是进程存在的唯一标识。

# 文件系统

**文件类型：**普通文件，目录，硬软连接（占用磁盘空间）；字符设备，块设备，套接字，管道（不占用磁盘空间）

- 硬链接：内存中有不同的dentry，指向相同的inode

## 文件系统的组成

**文件系统的组成：**Linux文件系统为每个文件分配两个数据结构：**索引节点**（index node）和**目录项**（directory entry）

- **inode索引节点：**inode是文件的唯一标识，储存在磁盘中。 记录文件的元信息，数据在磁盘中的位置，inode编号，文件大小，访问权限，创建时间，修改时间，引用计数等。引用计数dentry引用inode的次数，引用计数为0时删除inode释放磁盘。
- **dentry目录项：** 存放在内存中，由内核维护。用来记录文件的名字，索引节点指针一级其他目录项的层级关联关系。多个目录项关联洗起来形成目录结构。

**文件数据如何存储在硬盘上：**磁盘读写最小单位是**扇区**，只有512B大小。以扇区为单位读写单位效率低。文件系统把多个扇区组成一个**逻辑块**（Linux中是4KB，8个扇区），每次读写8个扇区，提高读写效率。

- 磁盘格式化时分为三个存储区域：超级块，索引节点区和数据块。
  - **超级块：**文件系统挂载时进入内存，用来存储文件系统的详细信息，如块个数，块大小，空闲块等。
  - **索引节点区：**当文件访问时进入内存，用来存储索引节点。
  - **数据块区：**用来存储文件或目录数据。

**目录和目录项区别**：目录是文件（保存目录下子目录和文件的目录项），目录项是内核的一个数据结构。

![](src\文件存储.png)

## 虚拟文件系统

文件系统种类繁多，**屏蔽不同文件系统细节，对用户统一的接口**，在用户层和文件系统层引入中间层，这个中间层就称为**虚拟文件系统**（Virtual File System, VFS）。

Linux支持的文件系统根据存储位置的不同，可以把文件系统分为三类：

- **磁盘的文件系统：**直接把数据存储在磁盘中，比如Ext 2/3/4，XFS等
- **内存文件系统：**这类文件系统的数据存储在内存上，比如经常用到的`/proc`和`/sys`，读写这类文件，实际上再读写内核中相关数据。
- **网络文件系统：**用来访问其他计算机主机数据的文件系统，比如NFS，SMB等。

文件系统要先挂在到某个目录才能正常使用，Linux启动时，会把文件系统挂载到根目录。

![](src\虚拟文件系统.png)

**文件的使用：**

先open()打开，write()写入，close()关闭

1. **open：**为维护文件描述符建立了三张表：
   - **进程级的文件描述符表：**PCB（task_truct）中的files_struct指针，**文件描述符表**
     1. **控制标志**
     2. **打开文件描述体指针**（使用dup()可以多个描述符（索引）指向同一个打开文件描述体）
   - **系统级的文件描述符表：**对系统中所有打开的文件维护了一个描述符表，也被称之为**打开文件表**，表中条目称为打开文件描述体：
     1. **打开文件偏移量**（read()，write()，lseek()更新）
     2. **文件访问模式和状态标识**（open()的两个参数）
     3. **inode索引**
   - **文件系统的i-node：**
     1. **文件类型：**常规文件，目录，套接字，管道
     2. **访问权限：**rwx
     3. **文件大小：**
     4. **内存中的副本：**还包括**引用计数**，所在设备号，以及一些临时属性

**文件的存储：**

| 方式     | 访问磁盘次数       | 实现方式                                                     | 优点 | 缺点                                                         |
| -------- | ------------------ | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| 顺序分配 | 需访问磁盘一次     | 文件存放在磁盘连续的物理空间中，文件紧密相连读写效率高，一次磁盘寻道可以读出整个文件。文件头中保存起始位置和长度。 |      | 磁盘空间碎片（删除文件空闲空间利用），文件长度不易扩展（因紧密相连），只能挪动解决效率太低。 |
| 链表分配 | 需访问磁盘n次      | **隐式链表：**文件头包含第一块和最后一块的位置，中间每个数据块存放下一个数据块位置，这样从链头顺着指针可以找到所有数据块。<br>**显式链表：**把每个数据块的指针，显式的存放在内存的一张表中，每个表项存放链接指针指向下一个数据块号，链表尾-1。内存中的这样一个表格称为文件分配表（FAT） |      |                                                              |
| 索引分配 | m级需访问磁盘m+1次 |                                                              |      |                                                              |

1. **连续空间存放方式：**

   

   

   **缺点：**

2. **非连续空间存放方式：**

   1. **链表方式：**链表的存放时离散的，可以消除磁盘碎片，同时文件的长度可以动态扩展

      1. **隐式链表：**文件头包含第一块和最后一块的位置，中间每个数据块存放下一个数据块位置，这样从链头顺着指针可以找到所有数据块。

         **缺点：**

         - 无法直接访问数据块，只能通过指针顺序访问文件
         - 数据块指针消耗一定的存储空间
         - 稳定性较差，如果链表中的指针丢失或损坏，会导致文件数据丢失

      2. **显式链表：**把每个数据块的指针，显式的存放在内存的一张表中，每个表项存放链接指针指向下一个数据块号，链表尾-1。内存中的这样一个表格称为文件分配表（FAT）。

         **优点：**查找是在内存中，提高了检索速度，减少了磁盘IO。

         **缺点：**不适用于大磁盘，建表内存占用太多。

   2. **索引方式：**

      链表的方式解决了连续分配的磁盘碎片和文件动态扩展，但是不能支持直接访问。

      **索引方式：**为每个文件创建一个索引数据块，里面存放的时指向文件数据块的指针列表。在文件头中包含指向索引数据块的指针，这样可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。创建文件时，索引块的所有指针都设为空。当首次写入第i块时，先从空闲空间取得一个块，再将其地址写道索引块的第i个条目。

      多级索引。

      **优点：**

      - 文件的创建、增大、缩小很方便
      - 不会有碎片的问题
      - 支持顺序读写和随机读写
