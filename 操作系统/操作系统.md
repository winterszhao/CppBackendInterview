## 操作系统

为了屏蔽底层不同硬件的差异，使应用层的用户在编写程序时调用统一的接口

CPU位数 ALU算数逻辑单元的宽度，数据总线的条数（32位是这样，别的位数cpu不是这样）

# 内存管理

## 虚拟地址

- **why：**操作系统的进程是共享cpu和主存资源的，

  1. 如果需要太多内存进程无法生存
  2. 多个进程之间直接使用物理地址，会导致物理内存争夺和践踏

- **what：**操作系统提供的一种机制，cpu通过MMU将不同进程的虚拟地址和物理地址映射起来

- **how：**

  1. **段式管理：**

     - **解决的问题：**解决多进程直接使用物理内存的争夺践踏问题。

     - **解决：**（符合用户的观点）程序由不同逻辑分段组成：C语言**代码段，数据段，BSS段，堆段，栈段，文件映射区**。不同分段有不同属性，所以用分段的形式把这些段分离出来

       虚拟地址分为两部分：**段选择子**和**段内偏移量**

       1. **段选择子**保存在段寄存器中：段号和特权标志位
       - **段号：**段表的索引，找到段表中的段内描述符：段基地址，段界限，特权等级
       
       2. **段内偏移量**：应位于0和段界限之间，如果合法，物理地址 = 段基地址+段内偏移量
       
     - **引入的问题**

       1. **内存碎片：**
       
          - **外部内存碎⽚：**也就是产⽣了多个不连续的⼩物理内存，导致新的程序⽆法被装载；
       
            **解决：**内存交换，内存交换到磁盘的swap空间上，再紧挨着上个被占用的空间交换回内存中。
       
          - **内部内存碎⽚：**程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并**不是很常使⽤**，这也会导致内存的浪费。
       
       2. **内存交换效率低：**每次交换都要把整个程序一大段连续内存写到硬盘上，这样效率很低。
  
     ![](src\段式管理.png)
  
  2. **页式管理：**
  
     - **解决的问题：**段式管理有内存碎片和交换效率低的问题。
     - **解决：**分⻚是**把整个虚拟和物理内存空间切成⼀段段固定尺⼨的⼤⼩**。这样⼀个连续并且尺⼨固定 的内存空间，我们叫⻚（Page）。在 Linux 下，每⼀⻚的⼤⼩为 4KB 。
  
       - 这样释放内存是以页为单位，不会产生无法给进程使用的小内存。换入换出只是少数的页，内存交换的效率更高。
  
       - 因为换入换出效率更高：程序运行时，无需把页加载到物理内存中，需要用到虚拟内存页的指令和数据时，再加载到物理内存里面去。
  
       - 虚拟内存与物理地址之间通过**页表**来映射：虚拟地址分为两个部分页号和页内偏移
  
         - 页号：页表的索引，页表包含物理页号（可找到每页所在物理内存的基地址）
         - 物理地址 = 物理页号+页内偏移
     - **引入的问题：**页表占用内存，每个进程都需要单独的页表映射整个物理地址。
  
  3. **多级页表和快表：**
  
     - **多级页表：**
  
       - **解决的问题：**每个进程都需要页表，只用单个页表划分虚拟内存，多个页表占用空间大。
       - **解决：**所以可以创建多级的页表，一级页表表示更大的范围，如果二级页表项没有被用到，就不创建这个页表项对应的二级页表，可以需要时才创建二级页表。
  
       ![多级页表](src\多级页表.png)
  
     - **引入的问题：**多级页表解决了空间消耗的问题，但是引入了额外的时间开销（地址多次转换）
  
  4. **快表TLB:**
  
     - **解决的问题：**多级页表的时间消耗。
     - **解决：**因为程序的执行是有空间有局部性的，整个程序的执行只局限于程序的某一部分。利用这一特性，把最常访问的页缓存起来放在CPU中就是快表。先查快表，如果没找到，再查常规页表。

4. **段页式内存管理：**

   分段和分页并不对立，可以组合起来在同一个系统中使用，组合起来称为段页式内存管理。

   - 先将程序划分为多个有逻辑意义的段，接着再把每个段划分为多个页。这样每个程序一张段表，段表中的地址是页表的起始地址。访问物理地址须景观三次内存访问：

     - 访问段表，获取页表起始地址

     - 访问页表，得到物理页号

     - 物理页号+页内偏移，得到物理地址

    ![段页式](src\段页式.png)

  5. **Linux内存管理：**

     Intel处理器：在段式管理的映射的地址上在加上再加上一层地址映射。段式管理先将**逻辑地址**映射成**线性地址**，然后再由页式管理将线性地址映射成物理地址。

     **Linux 内存：**主要采⽤的是⻚式内存管理，但同时也不可避免地涉及了段机制：**Linux**每个段都是从0开始的整个4GB虚拟空间（32位环境）**，也就是所有的段的起始地址都是一样的。这样Linux系统中的代码，所面对的地址空间都是线性地址空间（虚拟地址），这种错发相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。

     虚拟地址空间内部被分为**内核空间**和**用户空间**两部分：

     - 32位系统：寻址空间2^32->4G，内核空间高1G，用户低3G。64位系统：2^64内核高128T，用户空间低128T，中间未定义。

     - 进程在用户态时，只能访问用户空间。只有进入内核态后才能访问内核空间的内存。
     - 虽然每个进程都各自又独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样进程切换到内核态后，就可以很方便地访问内核空间内存。

     ![](src\内核和用户.png)

     用户空间：从低到高分别是7中不同的内存段

     1. 程序文件段.text：包括二进制可执行指令
     2. 已初始化数据段.data：包括静态常量
     3. 未初始化数据段.bss：包括未初始化的静态变量
     4. 堆段：包括动态分配的内存，**从低地址开始向上增长**
     5. 文件映射段：包括动态库，共享内存等，从低地址开始向上增长
     6. 栈段：包括局部变量和函数调用上下文等。栈大小固定一般是8M，操作系统也提供了参数来自定义大小。

# 进程与线程   ​ 

**并行与并发：**并行程序同时运行，并发程序交替运行

 **进程的状态：**

1. 创建状态（new）：进程正在被创建时的状态。
2. 就绪状态（Ready）：进程创建完成并初始化后进入就绪队列，转为就绪态。可运行，但是其他进程占用cpu时间片。
3. 运行状态（Running）：进程调度器选中后执行进程，正在运行，进程占用CPU时间片。
4. 阻塞状态（Block）：进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂停运行，这时，即使给它CPU控制权，它也无法运行。
5. 挂起状态（Suspended）：内存换出到磁盘，没有实际占用物理内存空间。阻塞，资源限制，用户调用系统函数pause。
   - 阻塞挂起态：进程在外存，等待某个事件出现。
   - 就绪挂起态：进程在外存，只要换入到内存立即执行
6. 结束状态（Exit）：进程正在从操作系统消失的状态。

# 文件系统

## 文件系统的组成

**文件系统的组成：**Linux文件系统为每个文件分配两个数据结构：**索引节点**（index node）和**目录项**（directory entry）

- **inode索引节点：** **记录文件的元信息，数据在磁盘中的位置，inode编号，文件大小，访问权限，创建时间，修改时间等**。inode是文件的唯一标识，储存在硬盘中，占据磁盘空间。
- **dentry目录项：** **用来记录文件的名字，索引节点指针一级其他目录项的层级关联关系。**多个目录项关联洗起来形成目录结构。存放在内存中，由内核维护。

**文件数据如何存储在硬盘上：**磁盘读写最小单位是**扇区**，只有512B大小。以扇区为单位读写单位效率低。文件系统把多个扇区组成一个**逻辑块**（Linux中是4KB，8个扇区），每次读写8个扇区，提高读写效率。

- 磁盘格式化时分为三个存储区域：超级块，索引节点区和数据块。
  - **超级块：**文件系统挂载时进入内存，用来存储文件系统的详细信息，如块个数，块大小，空闲块等。
  - **索引节点区：**当文件访问时进入内存，用来存储索引节点。
  - **数据块区：**用来存储文件或目录数据。

**目录和目录项区别**：目录是文件（保存目录下子目录和文件的目录项），目录项是内核的一个数据结构。

![](src\文件存储.png)

## 虚拟文件系统

文件系统种类繁多，**屏蔽不同文件系统细节，对用户统一的接口**，在用户层和文件系统层引入中间层，这个中间层就称为**虚拟文件系统**（Virtual File System, VFS）。

Linux支持的文件系统根据存储位置的不同，可以把文件系统分为三类：

- **磁盘的文件系统：**直接把数据存储在磁盘中，比如Ext 2/3/4，XFS等
- **内存文件系统：**这类文件系统的数据存储在内存上，比如经常用到的`/proc`和`/sys`，读写这类文件，实际上再读写内核中相关数据。
- **网络文件系统：**用来访问其他计算机主机数据的文件系统，比如NFS，SMB等。

文件系统要先挂在到某个目录才能正常使用，Linux启动时，会把文件系统挂载到根目录。

![](src\虚拟文件系统.png)

**文件的使用：**

先open()打开，write()写入，close()关闭

1. **open：**为维护文件描述符建立了三张表：
   - **进程级的文件描述符表：**PCB（task_truct）中的files_struct指针，**文件描述符表**
     1. **控制标志**
     2. **打开文件描述体指针**（使用dup()可以多个描述符（索引）指向同一个打开文件描述体）
   - **系统级的文件描述符表：**对系统中所有打开的文件维护了一个描述符表，也被称之为**打开文件表**，表中条目称为打开文件描述体：
     1. **打开文件偏移量**（read()，write()，lseek()更新）
     2. **文件访问模式和状态标识**（open()的两个参数）
     3. **inode索引**
   - **文件系统的i-node：**
     1. **文件类型：**常规文件，目录，套接字，管道
     2. **访问权限：**rwx
     3. **文件大小：**
     4. **内存中的副本：**还包括**引用计数**，所在设备号，以及一些临时属性

**文件的存储：**

| 方式     | 访问磁盘次数       | 实现方式                                                     | 优点 | 缺点                                                         |
| -------- | ------------------ | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| 顺序分配 | 需访问磁盘一次     | 文件存放在磁盘连续的物理空间中，文件紧密相连读写效率高，一次磁盘寻道可以读出整个文件。文件头中保存起始位置和长度。 |      | 磁盘空间碎片（删除文件空闲空间利用），文件长度不易扩展（因紧密相连），只能挪动解决效率太低。 |
| 链表分配 | 需访问磁盘n次      | **隐式链表：**文件头包含第一块和最后一块的位置，中间每个数据块存放下一个数据块位置，这样从链头顺着指针可以找到所有数据块。<br>**显式链表：**把每个数据块的指针，显式的存放在内存的一张表中，每个表项存放链接指针指向下一个数据块号，链表尾-1。内存中的这样一个表格称为文件分配表（FAT） |      |                                                              |
| 索引分配 | m级需访问磁盘m+1次 |                                                              |      |                                                              |

1. **连续空间存放方式：**

   

   

   **缺点：**

2. **非连续空间存放方式：**

   1. **链表方式：**链表的存放时离散的，可以消除磁盘碎片，同时文件的长度可以动态扩展

      1. **隐式链表：**文件头包含第一块和最后一块的位置，中间每个数据块存放下一个数据块位置，这样从链头顺着指针可以找到所有数据块。

         **缺点：**

         - 无法直接访问数据块，只能通过指针顺序访问文件
         - 数据块指针消耗一定的存储空间
         - 稳定性较差，如果链表中的指针丢失或损坏，会导致文件数据丢失

      2. **显式链表：**把每个数据块的指针，显式的存放在内存的一张表中，每个表项存放链接指针指向下一个数据块号，链表尾-1。内存中的这样一个表格称为文件分配表（FAT）。

         **优点：**查找是在内存中，提高了检索速度，减少了磁盘IO。

         **缺点：**不适用于大磁盘，建表内存占用太多。

   2. **索引方式：**

      链表的方式解决了连续分配的磁盘碎片和文件动态扩展，但是不能支持直接访问。

      **索引方式：**为每个文件创建一个索引数据块，里面存放的时指向文件数据块的指针列表。在文件头中包含指向索引数据块的指针，这样可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。创建文件时，索引块的所有指针都设为空。当首次写入第i块时，先从空闲空间取得一个块，再将其地址写道索引块的第i个条目。

      多级索引。

      **优点：**

      - 文件的创建、增大、缩小很方便
      - 不会有碎片的问题
      - 支持顺序读写和随机读写
