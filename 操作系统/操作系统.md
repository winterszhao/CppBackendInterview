## 操作系统

为了屏蔽底层不同硬件的差异，使应用层的用户在编写程序时调用统一的接口

CPU位数 ALU算数逻辑单元的宽度，数据总线的条数（32位是这样，别的位数cpu不是这样）

# 内存管理

## 虚拟地址

- **why：**操作系统的进程是共享cpu和主存资源的，

  1. 如果需要太多内存进程无法生存
  2. 多个进程之间直接使用物理地址，会导致物理内存争夺和践踏

- **what：**操作系统提供的一种机制，cpu通过MMU将不同进程的虚拟地址和物理地址映射起来

- **how：**

  1. **段式管理：**

     - **解决的问题：**解决多进程直接使用物理内存的争夺践踏问题。

     - **解决：**（符合用户的观点）程序由不同逻辑分段组成：C语言**代码段，数据段，BSS段，堆段，栈段，文件映射区**。不同分段有不同属性，所以用分段的形式把这些段分离出来

       虚拟地址分为两部分：**段选择子**和**段内偏移量**

       1. **段选择子**保存在段寄存器中：段号和特权标志位
       - **段号：**段表的索引，找到段表中的段内描述符：段基地址，段界限，特权等级
       
       2. **段内偏移量**：应位于0和段界限之间，如果合法，物理地址 = 段基地址+段内偏移量
       
     - **引入的问题**

       1. **内存碎片：**
       
          - **外部内存碎⽚：**也就是产⽣了多个不连续的⼩物理内存，导致新的程序⽆法被装载；
       
            **解决：**内存交换，内存交换到磁盘的swap空间上，再紧挨着上个被占用的空间交换回内存中。
       
          - **内部内存碎⽚：**程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并**不是很常使⽤**，这也会导致内存的浪费。
       
       2. **内存交换效率低：**每次交换都要把整个程序一大段连续内存写到硬盘上，这样效率很低。
  
     ![](C:\Users\winterszhao\Desktop\面试\操作系统\src\段式管理.png)
  
  2. **页式管理：**
  
     - **解决的问题：**段式管理有内存碎片和交换效率低的问题。
     - **解决：**分⻚是**把整个虚拟和物理内存空间切成⼀段段固定尺⼨的⼤⼩**。这样⼀个连续并且尺⼨固定 的内存空间，我们叫⻚（Page）。在 Linux 下，每⼀⻚的⼤⼩为 4KB 。
  
       - 这样释放内存是以页为单位，不会产生无法给进程使用的小内存。换入换出只是少数的页，内存交换的效率更高。
  
       - 因为换入换出效率更高：程序运行时，无需把页加载到物理内存中，需要用到虚拟内存页的指令和数据时，再加载到物理内存里面去。
  
       - 虚拟内存与物理地址之间通过**页表**来映射：虚拟地址分为两个部分页号和页内偏移
  
         - 页号：页表的索引，页表包含物理页号（可找到每页所在物理内存的基地址）
         - 物理地址 = 物理页号+页内偏移
     - **引入的问题：**页表占用内存，每个进程都需要单独的页表映射整个物理地址。
  
  3. **多级页表和快表：**
  
     - **多级页表：**
  
       - **解决的问题：**每个进程都需要页表，只用单个页表划分虚拟内存，多个页表占用空间大。
       - **解决：**所以可以创建多级的页表，一级页表表示更大的范围，如果二级页表项没有被用到，就不创建这个页表项对应的二级页表，可以需要时才创建二级页表。
  
       ![多级页表](C:\Users\winterszhao\Desktop\面试\操作系统\src\多级页表.png)
  
     - **引入的问题：**多级页表解决了空间消耗的问题，但是引入了额外的时间开销（地址多次转换）
  
  4. **快表TLB:**
  
     - **解决的问题：**多级页表的时间消耗。
     - **解决：**因为程序的执行是有空间有局部性的，整个程序的执行只局限于程序的某一部分。利用这一特性，把最常访问的页缓存起来放在CPU中就是快表。先查快表，如果没找到，再查常规页表。

4. **段页式内存管理：**

   分段和分页并不对立，可以组合起来在同一个系统中使用，组合起来称为段页式内存管理。

   - 先将程序划分为多个有逻辑意义的段，接着再把每个段划分为多个页。这样每个程序一张段表，段表中的地址是页表的起始地址。访问物理地址须景观三次内存访问：

     - 访问段表，获取页表起始地址

     - 访问页表，得到物理页号

     - 物理页号+页内偏移，得到物理地址

    ![段页式](C:\Users\winterszhao\Desktop\面试\操作系统\src\段页式.png)

  5. **Linux内存管理：**

     Intel处理器：在段式管理的映射的地址上在加上再加上一层地址映射。段式管理先将**逻辑地址**映射成**线性地址**，然后再由页式管理将线性地址映射成物理地址。

     **Linux 内存：**主要采⽤的是⻚式内存管理，但同时也不可避免地涉及了段机制：**Linux**每个段都是从0开始的整个4GB虚拟空间（32位环境）**，也就是所有的段的起始地址都是一样的。这样Linux系统中的代码，所面对的地址空间都是线性地址空间（虚拟地址），这种错发相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。

     虚拟地址空间内部被分为**内核空间**和**用户空间**两部分：

     - 32位系统：寻址空间2^32->4G，内核空间高1G，用户低3G。64位系统：2^64内核高128T，用户空间低128T，中间未定义。

     - 进程在用户态时，只能访问用户空间。只有进入内核态后才能访问内核空间的内存。
     - 虽然每个进程都各自又独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样进程切换到内核态后，就可以很方便地访问内核空间内存。

     ![](C:\Users\winterszhao\Desktop\面试\操作系统\src\内核和用户.png)

     用户空间：从低到高分别是7中不同的内存段

     1. 程序文件段.text：包括二进制可执行指令
     2. 已初始化数据段.data：包括静态常量
     3. 未初始化数据段.bss：包括未初始化的静态变量
     4. 堆段：包括动态分配的内存，**从低地址开始向上增长**
     5. 文件映射段：包括动态库，共享内存等，从低地址开始向上增长
     6. 栈段：包括局部变量和函数调用上下文等。栈大小固定一般是8M，操作系统也提供了参数来自定义大小。

# 进程与线程   ​ 

**并行与并发：**并行程序同时运行，并发程序交替运行

 **进程的状态：**

1. 创建状态（new）：进程正在被创建时的状态。
2. 就绪状态（Ready）：进程创建完成并初始化后进入就绪队列，转为就绪态。可运行，但是其他进程占用cpu时间片。
3. 运行状态（Running）：进程调度器选中后执行进程，正在运行，进程占用CPU时间片。
4. 阻塞状态（Block）：进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂停运行，这时，即使给它CPU控制权，它也无法运行。
5. 挂起状态（Suspended）：内存换出到磁盘，没有实际占用物理内存空间。阻塞，资源限制，用户调用系统函数pause。
   - 阻塞挂起态：进程在外存，等待某个事件出现。
   - 就绪挂起态：进程在外存，只要换入到内存立即执行
6. 结束状态（Exit）：进程正在从操作系统消失的状态。

