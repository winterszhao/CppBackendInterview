数据（全局变量，静态全局变量，静态局部变量）

**用户空间：**

- 0-128M是预留的不可访问空间		0x00000000
- .text：代码段
- .data：数据段，初始化的数据（）
- .bss：bss段，未初始化的数据
- 堆heap
- 共享库.so
- .stack：栈（命令行参数和环境变量argc,argv,environ）                                       0xFFFFFFFF

**内核空间：**

- ZONE_DMA：DMA技术，加快硬盘访问
- ZONE_NORMAL
- ZONE_HIGHMEM：32位系统用于映射高于1G的物理内存

```c++
#include <stdio.h>
int main(int argc, char** argv, char** environ){
    // argc 命令行参数个数
    // argv 命令行参数
    // environ 环境变量
}
```

**程序的编译链接：**

**预编译：**处理预编译指令，`.i`文件，`gcc -E hello.c -o hello.i`

- 处理#开头的预编译指令：展开宏定义，处理条件编译指令，保留#pragma编译指令
- 删除所有注释，添加行号和文件名标识

**编译：**生成汇编代码，`.s`文件，`gcc -S hello.i -o hello.s`，

1. **词法分析：**源代码被输入扫描器，运用类似有限状态机的算法将源代码分割成一系列的记号（关键字，标识符，字面量，特殊符号）。
2. **语法分析：**记号通过上下文无关语法生成语法树（表达式为节点）。
3. **语义分析：**检查静态语义，分析语句是否合法。
4. **中间语言生成和优化**：直接在语法树上优化比较难，将语法树生成中间代码（三地址码或P-代码），对代码进行优化，生成汇编代码。

**汇编：**生成二进制目标文件，`.o`文件，`gcc -c hello.s -o hello.o`

**链接：**

1. **地址和空间分配：**
2. **符号决议：**
3. **重定位：**





1. 编译：`main.s`

   - 编译的四步
   - obj文件怎么组成
   - 编译过程中符号表怎么汇总
   - 符号表中的符号是定义还是引用，他们定义在哪些段上

   不会填符号的地址，所有数据0x0，所有函数名记偏移量：函数下一行指令地址-4(指针大小)

   代码的优化

   **汇总所有的符号：**

   C语言有强符号和弱符号的概念

   - 强符号：具有明确定义和唯一标识的符号，初始化过的变量。
   - 弱符号：程序中具有多个定义或者可以被其他符号覆盖的符号。在链接过程中，弱符号可能会被其他强符号或者弱符号所覆盖。
   - 多个同名强符号出错，同名强符号和弱符号选择强符号，多个同名弱符号选择内存占用较大的那个，多个弱符号内存占用相同看编译器实现

   objdump -t main.o 发现弱符号在`*COM*`块中

   extern 修饰的变量函数在`*UND*`块中

   `*COM*`和`*UND*`这些找不到定义的符号定义的叫符号的引用，

2. 汇编：

   根据特定平台和机器码直接转换

3. 二进制可重定位二进制文件`main.o，main.obj`：

   组成格式objdump，查看符号没有分配内存地址

   **查看文件头elf header：**`readelf -h main.o` ，其中size of this header: 52字节0x34，flg:AWX读写执行

   **查看文件的段：**`objdump -S main.o`每个段的反汇编信息，

   `readelf -S main.o`查看段表信息，`readelf -h main.o` 查看文件头信息

   - .text：0x34
   - .data：4字节对齐0x50
   - .rodata：只读数据段存常量
   - .bss：0x5c，发现大小不对，少一个整形大小。定义了一个弱符号，因为弱符号有可能被其他文件的强符号或者内存更大的弱符号替换所以编译过程不在.bss段预留空间，链接时再确定。
   - .comment：起始空间还是0x5c，发现bss段不占文件的空间（不需要存初始值）
   - section table：段表，记录段的详细信息，elf header文件头中保存段表的起始地址。

   `objdump -s main.o`段的内容

**链接：**

1. **合并所有obj文件的段，并调整段偏移和段长度，合并符号表**，**进行符号解析**，**分配地址**。

   **合并obj文件的段：**并调整段偏移和段长度

   - 所有相同属性的段进行合并（读写执行.text .rodata合并在一起，.data .bss合并在一起）

   - 如果不合并段是按页面对齐的（4K），如果有多个文件多个段占据内存很大

   **合并符号表：**符号引用的地方找到符号定义的地方

   - 多个文件都是单独编译，链接器只对global的符号进行处理，local不管（static）
   - 链接时所有符号引用的地方都要找到，否则报错无法解决的外部符号。如果两个同名的定义符号，报错重定义符号。

   **分配内存地址：**符号的重定位

   - 数据符号：虚拟地址
   - 函数符号：相对下一条指令地址的偏移

**程序加载：**

   可执行文件本身还是按段来存储，只不过program headers中的LOAD项来指明哪些段存在同一个页面上

   mmap 深入理解计算机系统第9章

**内存映射：**

   ​							                                 mmap                                      多级页表

   程序的磁盘上各种段的磁盘DP 页   -------------->    虚拟地址空间     --------------->   物理页   

   

   从elf header中看到，可执行文件比obj文件还多一个program headers：指明哪些段在一个页上存储

   `readelf -l run`可以看到有LOAD页，.text代码段，.data .bss按执行权限加载在不同LOAD页上

 **程序执行：**发现elf header中entry point程序的入口地址相同。  

   

2. 可执行文件：

   1. 组成格式
   2. 为什么能执行？从哪里执行？CPU怎么知道怎么执行

**程序的运行：**

1. 创建虚拟地址空间到物理内存的映射（创建内核地址映射结构体），创建页目录和页表
2. 加载代码段和数据段
3. 把可执行文件的入口地址（elf header）写到CPU的pc寄存器里面